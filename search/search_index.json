{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"reference/attrs/","title":"attrs","text":""},{"location":"reference/attrs/#mongospecs.attrs","title":"attrs","text":""},{"location":"reference/attrs/#mongospecs.attrs.SpecAdapter","title":"SpecAdapter  <code>module-attribute</code>","text":"<pre><code>SpecAdapter = AdapterBuilder()\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.AdapterBuilder","title":"AdapterBuilder","text":"Source code in <code>mongospecs/attrs.py</code> <pre><code>class AdapterBuilder:\n    def __call__(\n        self, obj: type[AttrsInstance], *, collection: str, client: Optional[MongoClient] = None, **kwds: Any\n    ) -&gt; Any:\n        @attrs.define(kw_only=True)\n        class BuiltSpecAdapter(Spec, obj):  # type: ignore\n            ...\n\n        BuiltSpecAdapter.__name__ = f\"{obj.__name__}SpecAdapter\"\n        BuiltSpecAdapter._collection = collection\n        BuiltSpecAdapter.__doc__ = obj.__doc__\n        if client:\n            BuiltSpecAdapter._client = client\n        return BuiltSpecAdapter  # type: ignore\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.AttrsAdapter","title":"AttrsAdapter","text":"<p>             Bases: <code>AttrsInstance</code>, <code>SpecProtocol</code></p> Source code in <code>mongospecs/attrs.py</code> <pre><code>class AttrsAdapter(AttrsInstance, SpecProtocol): ...\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec","title":"Spec","text":"<p>             Bases: <code>SpecBase</code></p> Source code in <code>mongospecs/attrs.py</code> <pre><code>@attrs.define(kw_only=True)\nclass Spec(SpecBase):\n    _id: Optional[ObjectId] = attrs.field(default=None, alias=\"_id\", repr=True)  # type: ignore[assignment]\n\n    @property\n    def id(self) -&gt; Optional[ObjectId]:\n        return self._id\n\n    @id.setter\n    def id(self, value: ObjectId) -&gt; None:\n        self._id = value\n\n    @classmethod\n    def get_fields(cls) -&gt; set[str]:\n        return {f.name for f in attrs.fields(cls)}  # type: ignore[misc]\n\n    def encode(self, **encode_kwargs: Any) -&gt; bytes:\n        return msgspec.json.encode(self, **encode_kwargs) if encode_kwargs else MongoEncoder.encode(self)\n\n    def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n        return msgspec.json.decode(data, type=self.__class__, dec_hook=mongo_dec_hook, **decode_kwargs)\n\n    def to_json_type(self) -&gt; Any:\n        return attrs.asdict(\n            self,\n            filter=lambda attr, value: value is not Empty or (attr.name == \"_id\" and value is not None),\n            value_serializer=attrs_serializer,\n        )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return attrs.asdict(self, recurse=False).copy()\n\n    def to_tuple(self) -&gt; tuple[Any, ...]:\n        return attrs.astuple(self)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.id","title":"id  <code>property</code> <code>writable</code>","text":"<pre><code>id: Optional[ObjectId]\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    return cls.one({\"_id\": id}, **kwargs)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n    ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    filter = to_refs(filter)\n\n    if filter:\n        return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n    else:\n        return cls.get_collection().estimated_document_count(**kwargs)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n    return msgspec.json.decode(data, type=self.__class__, dec_hook=mongo_dec_hook, **decode_kwargs)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n\n    assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n    # Send delete signal\n    signal(\"delete\").send(self.__class__, frames=[self])\n\n    # Delete the document\n    self.get_collection().delete_one({\"_id\": self._id})\n\n    # Send deleted signal\n    signal(\"deleted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n    # Send delete signal\n    signal(\"delete\").send(cls, frames=frames)\n\n    # Prepare the documents to be deleted\n    ids = [f._id for f in frames]\n\n    # Delete the documents\n    cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    # Send deleted signal\n    signal(\"deleted\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes:\n    return msgspec.json.encode(self, **encode_kwargs) if encode_kwargs else MongoEncoder.encode(self)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Make sure we found documents\n    if not documents:\n        return []\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return documents\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return {}\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return document\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Self\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; Self:\n    return cls(**document)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.from_raw_bson","title":"from_raw_bson  <code>classmethod</code>","text":"<pre><code>from_raw_bson(raw_bson) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_raw_bson(cls, raw_bson) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    if cls._collection_context is not None:\n        return cls._collection_context\n\n    return getattr(cls.get_db(), cls._collection or cls.__name__)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    if not cls._client:\n        raise NotImplementedError(\"_client is not setup yet\")\n    if cls._db is not None:\n        return getattr(cls._client, cls._db.name)\n    return cls._client.get_default_database()\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]:\n    return {f.name for f in attrs.fields(cls)}  # type: ignore[misc]\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n    return [d[\"_id\"] for d in list(documents)]\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    # Send insert signal\n    signal(\"insert\").send(self.__class__, frames=[self])\n\n    document_dict = self.to_dict()\n    if not self._id:\n        document_dict.pop(\"_id\", None)\n    # Prepare the document to be inserted\n    document = to_refs(document_dict)\n\n    # Insert the document and update the Id\n    self._id = self.get_collection().insert_one(document).inserted_id\n\n    # Send inserted signal\n    signal(\"inserted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    # Send insert signal\n    signal(\"insert\").send(cls, frames=frames)\n\n    # Prepare the documents to be inserted\n    _documents = [to_refs(f.to_dict()) for f in frames]\n\n    for _document in _documents:\n        if not _document[\"_id\"]:\n            _document.pop(\"_id\")\n\n    # Bulk insert\n    ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n    # Apply the Ids to the frames\n    for i, id in enumerate(ids):\n        frames[i]._id = id\n\n    # Send inserted signal\n    signal(\"inserted\").send(cls, frames=frames)\n\n    return frames\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    signal(event).connect(func, sender=cls)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return [cls(**d) for d in documents]\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return None\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return cls.from_document(document)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    frame = self.find_one({\"_id\": self._id}, **kwargs)\n    for field in frame:\n        setattr(self, field, frame[field])\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    signal(event).disconnect(func, sender=cls)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return attrs.asdict(self, recurse=False).copy()\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; Any\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def to_json_type(self) -&gt; Any:\n    return attrs.asdict(\n        self,\n        filter=lambda attr, value: value is not Empty or (attr.name == \"_id\" and value is not None),\n        value_serializer=attrs_serializer,\n    )\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]:\n    return attrs.astuple(self)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Clear the fields from the document and build the unset object\n    unset = {}\n    for field in fields:\n        setattr(self, field, self._empty_type)\n        unset[field] = True\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Clear the fields from the documents and build a list of ids to\n    # update.\n    ids = []\n    for frame in frames:\n        if frame._id:\n            ids.append(frame._id)\n\n    # Build the unset object\n    unset = {}\n    for field in fields:\n        unset[field] = True\n        for frame in frames:\n            frame.to_dict().pop(field, None)\n\n    # Update the document\n    cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    self_document = self.to_dict()\n    assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        document = {}\n        for field in fields:\n            document[field] = self._path_to_value(field, self_document)\n    else:\n        document = self_document\n\n    # Prepare the document to be updated\n    document = to_refs(document)\n    document.pop(\"_id\", None)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Prepare the documents to be updated\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        _documents = []\n        for frame in frames:\n            document = {\"_id\": frame._id}\n            for field in fields:\n                document[field] = cls._path_to_value(field, frame.to_dict())\n            _documents.append(to_refs(document))\n    else:\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n    # Update the documents\n    requests = []\n    for _document in _documents:\n        _id = _document.pop(\"_id\")\n        requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n    cls.get_collection().bulk_write(requests)\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n\n    # If no `_id` is provided then we insert the document\n    if not self._id:\n        return self.insert()\n\n    # If an `_id` is provided then we need to check if it exists before\n    # performing the `upsert`.\n    #\n    if self.count({\"_id\": self._id}) == 0:\n        self.insert()\n    else:\n        self.update(*fields)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.Spec.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n    existing_context = getattr(cls, \"_collection_context\", None)\n\n    try:\n        collection = cls.get_collection()\n        cls._collection_context = collection.with_options(**options)\n        yield cls._collection_context\n\n    finally:\n        if cls._collection_context is None:\n            del cls._collection_context\n        else:\n            cls._collection_context = existing_context\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.SubSpec","title":"SubSpec","text":"<p>             Bases: <code>SubSpecBase</code></p> Source code in <code>mongospecs/attrs.py</code> <pre><code>@attrs.define(kw_only=True)\nclass SubSpec(SubSpecBase):\n    _parent: ClassVar[Any] = Spec\n\n    def get(self, name, default=None):  # -&gt; Any:\n        return self.to_dict().get(name, default)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return attrs.asdict(self)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.SubSpec.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def get(self, name, default=None):  # -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.SubSpec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return attrs.asdict(self)\n</code></pre>"},{"location":"reference/attrs/#mongospecs.attrs.attrs_serializer","title":"attrs_serializer","text":"<pre><code>attrs_serializer(inst: type, field: Attribute, value: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/attrs.py</code> <pre><code>def attrs_serializer(inst: type, field: attrs.Attribute, value: Any) -&gt; Any:\n    if type(value) == date:\n        return str(value)\n    elif isinstance(value, ObjectId):\n        return str(value)\n    elif isinstance(value, datetime):\n        return datetime.isoformat(value)\n    return value\n</code></pre>"},{"location":"reference/base/","title":"base","text":""},{"location":"reference/base/#mongospecs.base","title":"base","text":""},{"location":"reference/base/#mongospecs.base.RawDocuments","title":"RawDocuments  <code>module-attribute</code>","text":"<pre><code>RawDocuments = Sequence[dict[str, Any]]\n</code></pre>"},{"location":"reference/base/#mongospecs.base.Specs","title":"Specs  <code>module-attribute</code>","text":"<pre><code>Specs = Sequence['SpecBase']\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecsOrRawDocuments","title":"SpecsOrRawDocuments  <code>module-attribute</code>","text":"<pre><code>SpecsOrRawDocuments = Union[Specs, RawDocuments]\n</code></pre>"},{"location":"reference/base/#mongospecs.base.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase","title":"SpecBase","text":"Source code in <code>mongospecs/base.py</code> <pre><code>class SpecBase:\n    _client: ClassVar[Optional[MongoClient]] = None\n    _db: ClassVar[Optional[Database]] = None\n    _collection: ClassVar[Optional[str]] = None\n    _collection_context: ClassVar[Optional[Collection]] = None\n    _default_projection: ClassVar[dict[str, Any]] = {}\n    _empty_type: ClassVar[Any] = Empty\n    _id: Union[EmptyObject, ObjectId]\n\n    @classmethod\n    def get_fields(cls) -&gt; set[str]:\n        raise NotImplementedError\n\n    @classmethod\n    def from_document(cls, document: dict[str, Any]) -&gt; Self:\n        return cls(**document)\n\n    @classmethod\n    def from_raw_bson(cls, raw_bson) -&gt; Any:\n        pass\n\n    def get(self, name, default=None) -&gt; Any:\n        return self.to_dict().get(name, default)\n\n    def encode(self, **encode_kwargs: Any) -&gt; bytes:\n        raise NotImplementedError\n\n    def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n        raise NotImplementedError\n\n    def to_json_type(self) -&gt; dict[str, Any]:\n        raise NotImplementedError\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        raise NotImplementedError\n\n    def to_tuple(self) -&gt; tuple[Any, ...]:\n        raise NotImplementedError\n\n    # Operations\n    def insert(self) -&gt; None:\n        \"\"\"Insert this document\"\"\"\n        # Send insert signal\n        signal(\"insert\").send(self.__class__, frames=[self])\n\n        document_dict = self.to_dict()\n        if not self._id:\n            document_dict.pop(\"_id\", None)\n        # Prepare the document to be inserted\n        document = to_refs(document_dict)\n\n        # Insert the document and update the Id\n        self._id = self.get_collection().insert_one(document).inserted_id\n\n        # Send inserted signal\n        signal(\"inserted\").send(self.__class__, frames=[self])\n\n    def unset(self, *fields: Any) -&gt; None:\n        \"\"\"Unset the given list of fields for this document.\"\"\"\n\n        # Send update signal\n        signal(\"update\").send(self.__class__, frames=[self])\n\n        # Clear the fields from the document and build the unset object\n        unset = {}\n        for field in fields:\n            setattr(self, field, self._empty_type)\n            unset[field] = True\n\n        # Update the document\n        self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n        # Send updated signal\n        signal(\"updated\").send(self.__class__, frames=[self])\n\n    def update(self, *fields: Any) -&gt; None:\n        \"\"\"\n        Update this document. Optionally a specific list of fields to update can\n        be specified.\n        \"\"\"\n        self_document = self.to_dict()\n        assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n        # Send update signal\n        signal(\"update\").send(self.__class__, frames=[self])\n\n        # Check for selective updates\n        if len(fields) &gt; 0:\n            document = {}\n            for field in fields:\n                document[field] = self._path_to_value(field, self_document)\n        else:\n            document = self_document\n\n        # Prepare the document to be updated\n        document = to_refs(document)\n        document.pop(\"_id\", None)\n\n        # Update the document\n        self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n        # Send updated signal\n        signal(\"updated\").send(self.__class__, frames=[self])\n\n    def upsert(self, *fields: Any) -&gt; None:\n        \"\"\"\n        Update or Insert this document depending on whether it exists or not.\n        The presense of an `_id` value in the document is used to determine if\n        the document exists.\n\n        NOTE: This method is not the same as specifying the `upsert` flag when\n        calling MongoDB. When called for a document with an `_id` value, this\n        method will call the database to see if a record with that Id exists,\n        if not it will call `insert`, if so it will call `update`. This\n        operation is therefore not atomic and much slower than the equivalent\n        MongoDB operation (due to the extra call).\n        \"\"\"\n\n        # If no `_id` is provided then we insert the document\n        if not self._id:\n            return self.insert()\n\n        # If an `_id` is provided then we need to check if it exists before\n        # performing the `upsert`.\n        #\n        if self.count({\"_id\": self._id}) == 0:\n            self.insert()\n        else:\n            self.update(*fields)\n\n    def delete(self) -&gt; None:\n        \"\"\"Delete this document\"\"\"\n\n        assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n        # Send delete signal\n        signal(\"delete\").send(self.__class__, frames=[self])\n\n        # Delete the document\n        self.get_collection().delete_one({\"_id\": self._id})\n\n        # Send deleted signal\n        signal(\"deleted\").send(self.__class__, frames=[self])\n\n    @classmethod\n    def find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n        \"\"\"Return a list of documents matching the filter\"\"\"\n        # Flatten the projection\n        kwargs[\"projection\"], references, subs = cls._flatten_projection(\n            kwargs.get(\"projection\", cls._default_projection)\n        )\n\n        # Find the document\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n        # Make sure we found documents\n        if not documents:\n            return []\n\n        # Dereference the documents (if required)\n        if references:\n            cls._dereference(documents, references)\n\n        # Add sub-frames to the documents (if required)\n        if subs:\n            cls._apply_sub_frames(documents, subs)\n\n        return documents\n\n    @classmethod\n    def find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n        \"\"\"Return the first document matching the filter\"\"\"\n        # Flatten the projection\n        kwargs[\"projection\"], references, subs = cls._flatten_projection(\n            kwargs.get(\"projection\", cls._default_projection)\n        )\n\n        # Find the document\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n        # Make sure we found a document\n        if not document:\n            return {}\n\n        # Dereference the document (if required)\n        if references:\n            cls._dereference([document], references)\n\n        # Add sub-frames to the document (if required)\n        if subs:\n            cls._apply_sub_frames([document], subs)\n\n        return document\n\n    def reload(self, **kwargs):\n        \"\"\"Reload the document\"\"\"\n        frame = self.find_one({\"_id\": self._id}, **kwargs)\n        for field in frame:\n            setattr(self, field, frame[field])\n\n    @classmethod\n    def insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n        \"\"\"Insert a list of documents\"\"\"\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        # Send insert signal\n        signal(\"insert\").send(cls, frames=frames)\n\n        # Prepare the documents to be inserted\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n        for _document in _documents:\n            if not _document[\"_id\"]:\n                _document.pop(\"_id\")\n\n        # Bulk insert\n        ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n        # Apply the Ids to the frames\n        for i, id in enumerate(ids):\n            frames[i]._id = id\n\n        # Send inserted signal\n        signal(\"inserted\").send(cls, frames=frames)\n\n        return frames\n\n    @classmethod\n    def update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n        \"\"\"\n        Update multiple documents. Optionally a specific list of fields to\n        update can be specified.\n        \"\"\"\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        all_count = len(documents)\n        assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n        # Send update signal\n        signal(\"update\").send(cls, frames=frames)\n\n        # Prepare the documents to be updated\n\n        # Check for selective updates\n        if len(fields) &gt; 0:\n            _documents = []\n            for frame in frames:\n                document = {\"_id\": frame._id}\n                for field in fields:\n                    document[field] = cls._path_to_value(field, frame.to_dict())\n                _documents.append(to_refs(document))\n        else:\n            _documents = [to_refs(f.to_dict()) for f in frames]\n\n        # Update the documents\n        requests = []\n        for _document in _documents:\n            _id = _document.pop(\"_id\")\n            requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n        cls.get_collection().bulk_write(requests)\n\n        # Send updated signal\n        signal(\"updated\").send(cls, frames=frames)\n\n    @classmethod\n    def unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n        \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        all_count = len(documents)\n        assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n        # Send update signal\n        signal(\"update\").send(cls, frames=frames)\n\n        # Clear the fields from the documents and build a list of ids to\n        # update.\n        ids = []\n        for frame in frames:\n            if frame._id:\n                ids.append(frame._id)\n\n        # Build the unset object\n        unset = {}\n        for field in fields:\n            unset[field] = True\n            for frame in frames:\n                frame.to_dict().pop(field, None)\n\n        # Update the document\n        cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n        # Send updated signal\n        signal(\"updated\").send(cls, frames=frames)\n\n    @classmethod\n    def delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n        \"\"\"Delete multiple documents\"\"\"\n\n        # Ensure all documents have been converted to frames\n        frames = cls._ensure_frames(documents)\n\n        all_count = len(documents)\n        assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n        # Send delete signal\n        signal(\"delete\").send(cls, frames=frames)\n\n        # Prepare the documents to be deleted\n        ids = [f._id for f in frames]\n\n        # Delete the documents\n        cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n        # Send deleted signal\n        signal(\"deleted\").send(cls, frames=frames)\n\n    # Querying\n\n    @classmethod\n    def by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n        \"\"\"Get a document by ID\"\"\"\n        return cls.one({\"_id\": id}, **kwargs)\n\n    @classmethod\n    def count(cls, filter=None, **kwargs) -&gt; int:\n        \"\"\"Return a count of documents matching the filter\"\"\"\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        filter = to_refs(filter)\n\n        if filter:\n            return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n        else:\n            return cls.get_collection().estimated_document_count(**kwargs)\n\n    @classmethod\n    def ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n        \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n        # Find the documents\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n        return [d[\"_id\"] for d in list(documents)]\n\n    @classmethod\n    def one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n        \"\"\"Return the first spec object matching the filter\"\"\"\n        # Flatten the projection\n        kwargs[\"projection\"], references, subs = cls._flatten_projection(\n            kwargs.get(\"projection\", cls._default_projection)\n        )\n\n        # Find the document\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n        # Make sure we found a document\n        if not document:\n            return None\n\n        # Dereference the document (if required)\n        if references:\n            cls._dereference([document], references)\n\n        # Add sub-frames to the document (if required)\n        if subs:\n            cls._apply_sub_frames([document], subs)\n\n        return cls.from_document(document)\n\n    @classmethod\n    def many(cls, filter=None, **kwargs) -&gt; list[Self]:\n        \"\"\"Return a list of spec objects matching the filter\"\"\"\n        # Flatten the projection\n        kwargs[\"projection\"], references, subs = cls._flatten_projection(\n            kwargs.get(\"projection\", cls._default_projection)\n        )\n\n        # Find the documents\n        if isinstance(filter, (Condition, Group)):\n            filter = filter.to_dict()\n\n        documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n        # Dereference the documents (if required)\n        if references:\n            cls._dereference(documents, references)\n\n        # Add sub-frames to the documents (if required)\n        if subs:\n            cls._apply_sub_frames(documents, subs)\n\n        return [cls(**d) for d in documents]\n\n    @classmethod\n    def get_collection(cls) -&gt; Collection[Any]:\n        \"\"\"Return a reference to the database collection for the class\"\"\"\n        if cls._collection_context is not None:\n            return cls._collection_context\n\n        return getattr(cls.get_db(), cls._collection or cls.__name__)\n\n    @classmethod\n    def get_db(cls) -&gt; Database:\n        \"\"\"Return the database for the collection\"\"\"\n        if not cls._client:\n            raise NotImplementedError(\"_client is not setup yet\")\n        if cls._db is not None:\n            return getattr(cls._client, cls._db.name)\n        return cls._client.get_default_database()\n\n    @classmethod\n    @contextmanager\n    def with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n        existing_context = getattr(cls, \"_collection_context\", None)\n\n        try:\n            collection = cls.get_collection()\n            cls._collection_context = collection.with_options(**options)\n            yield cls._collection_context\n\n        finally:\n            if cls._collection_context is None:\n                del cls._collection_context\n            else:\n                cls._collection_context = existing_context\n\n    @classmethod\n    def _path_to_value(cls, path: str, parent_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Return a value from a dictionary at the given path\"\"\"\n        keys: list[str] = cls._path_to_keys(path)  # type: ignore\n\n        # Traverse to the tip of the path\n        child_dict = parent_dict\n        for key in keys[:-1]:\n            child_dict = child_dict.get(key)  # type: ignore[assignment]\n\n            # unpaved path- return None\n            if child_dict is None:\n                return None\n\n        return child_dict.get(keys[-1])\n\n    @classmethod\n    def _path_to_keys(cls, path: str) -&gt; list[str]:\n        \"\"\"Return a list of keys for a given path\"\"\"\n        return path.split(\".\")\n\n    @classmethod\n    def _ensure_frames(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n        \"\"\"\n        Ensure all items in a list are frames by converting those that aren't.\n        \"\"\"\n        frames = []\n        for document in documents:\n            if not isinstance(document, cls):\n                frames.append(cls(**document))\n            else:\n                frames.append(document)\n        return frames\n\n    @classmethod\n    def _apply_sub_frames(cls, documents: RawDocuments, subs: dict[str, Any]) -&gt; None:\n        \"\"\"Convert embedded documents to sub-frames for one or more documents\"\"\"\n\n        # Dereference each reference\n        for path, projection in subs.items():\n            # Get the SubFrame class we'll use to wrap the embedded document\n            sub = None\n            expect_map = False\n            if \"$sub\" in projection:\n                sub = projection.pop(\"$sub\")\n            elif \"$sub.\" in projection:\n                sub = projection.pop(\"$sub.\")\n                expect_map = True\n            else:\n                continue\n\n            # Add sub-frames to the documents\n            raw_subs: list[Any] = []\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if value is None:\n                    continue\n\n                if isinstance(value, dict):\n                    if expect_map:\n                        # Dictionary of embedded documents\n                        raw_subs += value.values()\n                        for k, v in value.items():\n                            if isinstance(v, list):\n                                value[k] = [sub(u) for u in v if isinstance(u, dict)]\n                            else:\n                                value[k] = sub(**v)\n\n                    # Single embedded document\n                    else:\n                        raw_subs.append(value)\n                        value = sub(**value)\n\n                elif isinstance(value, list):\n                    # List of embedded documents\n                    raw_subs += value\n                    value = [sub(**v) for v in value if isinstance(v, dict)]\n\n                else:\n                    raise TypeError(\"Not a supported sub-frame type\")\n\n                child_document = document\n                keys = cls._path_to_keys(path)\n                for key in keys[:-1]:\n                    child_document = child_document[key]\n                child_document[keys[-1]] = value\n\n            # Apply the projection to the list of sub frames\n            if projection:\n                sub._apply_projection(raw_subs, projection)\n\n    @classmethod\n    def _flatten_projection(cls, projection: dict[str, Any]) -&gt; tuple[dict[str, Any], dict[str, Any], dict[str, Any]]:\n        \"\"\"\n        Flatten a structured projection (structure projections support for\n        projections of (to be) dereferenced fields.\n        \"\"\"\n\n        # If `projection` is empty return a full projection based on `_fields`\n        if not projection:\n            return {f: True for f in cls.get_fields()}, {}, {}\n\n        # Flatten the projection\n        flat_projection = {}\n        references = {}\n        subs = {}\n        inclusive = True\n        for key, value in deepcopy(projection).items():\n            if isinstance(value, dict):\n                # Build the projection value for the field (allowing for\n                # special mongo directives).\n                values_to_project = {\n                    k: v for k, v in value.items() if k.startswith(\"$\") and k not in [\"$ref\", \"$sub\", \"$sub.\"]\n                }\n                project_value = True if len(values_to_project) == 0 else {key: values_to_project}\n\n                if project_value is not True:\n                    inclusive = False\n\n                # Store a reference/sub-frame projection\n                if \"$ref\" in value:\n                    references[key] = value\n\n                elif \"$sub\" in value or \"$sub.\" in value:\n                    subs[key] = value\n                    sub_frame = None\n                    if \"$sub\" in value:\n                        sub_frame = value[\"$sub\"]\n\n                    if \"$sub.\" in value:\n                        sub_frame = value[\"$sub.\"]\n\n                    if sub_frame:\n                        project_value = sub_frame._projection_to_paths(key, value)\n\n                if isinstance(project_value, dict):\n                    flat_projection.update(project_value)\n\n                else:\n                    flat_projection[key] = project_value\n\n            elif key == \"$ref\":\n                # Strip any $ref key\n                continue\n\n            elif key == \"$sub\" or key == \"$sub.\":\n                # Strip any $sub key\n                continue\n\n            elif key.startswith(\"$\"):\n                # Strip mongo operators\n                continue\n\n            else:\n                # Store the root projection value\n                flat_projection[key] = value\n                inclusive = False\n\n        # If only references and sub-frames where specified in the projection\n        # then return a full projection based on `_fields`.\n        if inclusive:\n            flat_projection = {f: True for f in cls.get_fields()}\n\n        return flat_projection, references, subs\n\n    @classmethod\n    def _dereference(cls, documents: RawDocuments, references: dict[str, Any]):\n        \"\"\"Dereference one or more documents\"\"\"\n\n        # Dereference each reference\n        for path, projection in references.items():\n            # Check there is a $ref in the projection, else skip it\n            if \"$ref\" not in projection:\n                continue\n\n            # Collect Ids of documents to dereference\n            ids = set()\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if not value:\n                    continue\n\n                if isinstance(value, list):\n                    ids.update(value)\n\n                elif isinstance(value, dict):\n                    ids.update(value.values())\n\n                else:\n                    ids.add(value)\n\n            # Find the referenced documents\n            ref = projection.pop(\"$ref\")\n\n            frames = ref.many({\"_id\": {\"$in\": list(ids)}}, projection=projection)\n            frames = {f._id: f for f in frames}\n\n            # Add dereferenced frames to the document\n            for document in documents:\n                value = cls._path_to_value(path, document)\n                if not value:\n                    continue\n\n                if isinstance(value, list):\n                    # List of references\n                    value = [frames[id] for id in value if id in frames]\n\n                elif isinstance(value, dict):\n                    # Dictionary of references\n                    value = {key: frames.get(id) for key, id in value.items()}\n\n                else:\n                    value = frames.get(value, None)\n\n                child_document = document\n                keys = cls._path_to_keys(path)\n                for key in keys[:-1]:\n                    child_document = child_document[key]\n                child_document[keys[-1]] = value\n\n    # Signals\n    @classmethod\n    def listen(cls, event: str, func: Callable) -&gt; None:\n        \"\"\"Add a callback for a signal against the class\"\"\"\n        signal(event).connect(func, sender=cls)\n\n    @classmethod\n    def stop_listening(cls, event: str, func: Callable) -&gt; None:\n        \"\"\"Remove a callback for a signal against the class\"\"\"\n        signal(event).disconnect(func, sender=cls)\n\n    # Integrity helpers\n\n    @classmethod\n    def cascade(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n        ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n        ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    @classmethod\n    def nullify(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n        ids = [to_refs(f) for f in frames]\n        ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n\n    @classmethod\n    def pull(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n        ids = [to_refs(f) for f in frames]\n        ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        return self._id == other._id\n\n    def __lt__(self, other: Any) -&gt; Any:\n        return self._id &lt; other._id\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    return cls.one({\"_id\": id}, **kwargs)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n    ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    filter = to_refs(filter)\n\n    if filter:\n        return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n    else:\n        return cls.get_collection().estimated_document_count(**kwargs)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n\n    assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n    # Send delete signal\n    signal(\"delete\").send(self.__class__, frames=[self])\n\n    # Delete the document\n    self.get_collection().delete_one({\"_id\": self._id})\n\n    # Send deleted signal\n    signal(\"deleted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n    # Send delete signal\n    signal(\"delete\").send(cls, frames=frames)\n\n    # Prepare the documents to be deleted\n    ids = [f._id for f in frames]\n\n    # Delete the documents\n    cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    # Send deleted signal\n    signal(\"deleted\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Make sure we found documents\n    if not documents:\n        return []\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return documents\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return {}\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return document\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Self\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; Self:\n    return cls(**document)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.from_raw_bson","title":"from_raw_bson  <code>classmethod</code>","text":"<pre><code>from_raw_bson(raw_bson) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_raw_bson(cls, raw_bson) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    if cls._collection_context is not None:\n        return cls._collection_context\n\n    return getattr(cls.get_db(), cls._collection or cls.__name__)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    if not cls._client:\n        raise NotImplementedError(\"_client is not setup yet\")\n    if cls._db is not None:\n        return getattr(cls._client, cls._db.name)\n    return cls._client.get_default_database()\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n    return [d[\"_id\"] for d in list(documents)]\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    # Send insert signal\n    signal(\"insert\").send(self.__class__, frames=[self])\n\n    document_dict = self.to_dict()\n    if not self._id:\n        document_dict.pop(\"_id\", None)\n    # Prepare the document to be inserted\n    document = to_refs(document_dict)\n\n    # Insert the document and update the Id\n    self._id = self.get_collection().insert_one(document).inserted_id\n\n    # Send inserted signal\n    signal(\"inserted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    # Send insert signal\n    signal(\"insert\").send(cls, frames=frames)\n\n    # Prepare the documents to be inserted\n    _documents = [to_refs(f.to_dict()) for f in frames]\n\n    for _document in _documents:\n        if not _document[\"_id\"]:\n            _document.pop(\"_id\")\n\n    # Bulk insert\n    ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n    # Apply the Ids to the frames\n    for i, id in enumerate(ids):\n        frames[i]._id = id\n\n    # Send inserted signal\n    signal(\"inserted\").send(cls, frames=frames)\n\n    return frames\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    signal(event).connect(func, sender=cls)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return [cls(**d) for d in documents]\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return None\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return cls.from_document(document)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    frame = self.find_one({\"_id\": self._id}, **kwargs)\n    for field in frame:\n        setattr(self, field, frame[field])\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    signal(event).disconnect(func, sender=cls)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_json_type(self) -&gt; dict[str, Any]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Clear the fields from the document and build the unset object\n    unset = {}\n    for field in fields:\n        setattr(self, field, self._empty_type)\n        unset[field] = True\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Clear the fields from the documents and build a list of ids to\n    # update.\n    ids = []\n    for frame in frames:\n        if frame._id:\n            ids.append(frame._id)\n\n    # Build the unset object\n    unset = {}\n    for field in fields:\n        unset[field] = True\n        for frame in frames:\n            frame.to_dict().pop(field, None)\n\n    # Update the document\n    cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    self_document = self.to_dict()\n    assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        document = {}\n        for field in fields:\n            document[field] = self._path_to_value(field, self_document)\n    else:\n        document = self_document\n\n    # Prepare the document to be updated\n    document = to_refs(document)\n    document.pop(\"_id\", None)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Prepare the documents to be updated\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        _documents = []\n        for frame in frames:\n            document = {\"_id\": frame._id}\n            for field in fields:\n                document[field] = cls._path_to_value(field, frame.to_dict())\n            _documents.append(to_refs(document))\n    else:\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n    # Update the documents\n    requests = []\n    for _document in _documents:\n        _id = _document.pop(\"_id\")\n        requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n    cls.get_collection().bulk_write(requests)\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n\n    # If no `_id` is provided then we insert the document\n    if not self._id:\n        return self.insert()\n\n    # If an `_id` is provided then we need to check if it exists before\n    # performing the `upsert`.\n    #\n    if self.count({\"_id\": self._id}) == 0:\n        self.insert()\n    else:\n        self.update(*fields)\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecBase.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n    existing_context = getattr(cls, \"_collection_context\", None)\n\n    try:\n        collection = cls.get_collection()\n        cls._collection_context = collection.with_options(**options)\n        yield cls._collection_context\n\n    finally:\n        if cls._collection_context is None:\n            del cls._collection_context\n        else:\n            cls._collection_context = existing_context\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol","title":"SpecProtocol","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>mongospecs/base.py</code> <pre><code>class SpecProtocol(Protocol):\n    _client: ClassVar[Optional[MongoClient]] = None\n    _db: ClassVar[Optional[Database]] = None\n    _collection: ClassVar[Optional[str]] = None\n    _collection_context: ClassVar[Optional[Collection]] = None\n    _default_projection: ClassVar[dict[str, Any]] = {}\n    _empty_type: ClassVar[Any] = Empty\n    _id: Union[EmptyObject, ObjectId]\n\n    @classmethod\n    def get_fields(cls) -&gt; set[str]: ...\n\n    @classmethod\n    def from_document(cls, document: dict[str, Any]) -&gt; Self: ...\n\n    def get(self, name, default=None) -&gt; Any: ...\n\n    def encode(self, **encode_kwargs: Any) -&gt; bytes: ...\n\n    def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any: ...\n\n    def to_json_type(self) -&gt; dict[str, Any]: ...\n\n    def to_dict(self) -&gt; dict[str, Any]: ...\n\n    def to_tuple(self) -&gt; tuple[Any, ...]: ...\n\n    # Operations\n    def insert(self) -&gt; None:\n        \"\"\"Insert this document\"\"\"\n        ...\n\n    def unset(self, *fields: Any) -&gt; None:\n        \"\"\"Unset the given list of fields for this document.\"\"\"\n        ...\n\n    def update(self, *fields: Any) -&gt; None:\n        \"\"\"\n        Update this document. Optionally a specific list of fields to update can\n        be specified.\n        \"\"\"\n        ...\n\n    def upsert(self, *fields: Any) -&gt; None:\n        \"\"\"\n        Update or Insert this document depending on whether it exists or not.\n        The presense of an `_id` value in the document is used to determine if\n        the document exists.\n\n        NOTE: This method is not the same as specifying the `upsert` flag when\n        calling MongoDB. When called for a document with an `_id` value, this\n        method will call the database to see if a record with that Id exists,\n        if not it will call `insert`, if so it will call `update`. This\n        operation is therefore not atomic and much slower than the equivalent\n        MongoDB operation (due to the extra call).\n        \"\"\"\n        ...\n\n    def delete(self) -&gt; None:\n        \"\"\"Delete this document\"\"\"\n        ...\n\n    @classmethod\n    def find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n        \"\"\"Return a list of documents matching the filter\"\"\"\n        ...\n\n    @classmethod\n    def find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n        \"\"\"Return the first document matching the filter\"\"\"\n        ...\n\n    def reload(self, **kwargs):\n        \"\"\"Reload the document\"\"\"\n        ...\n\n    @classmethod\n    def insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n        \"\"\"Insert a list of documents\"\"\"\n        ...\n\n    @classmethod\n    def update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n        \"\"\"\n        Update multiple documents. Optionally a specific list of fields to\n        update can be specified.\n        \"\"\"\n        ...\n\n    @classmethod\n    def unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n        \"\"\"Unset the given list of fields for given documents.\"\"\"\n        ...\n\n    @classmethod\n    def delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n        \"\"\"Delete multiple documents\"\"\"\n        ...\n\n    # Querying\n\n    @classmethod\n    def by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n        \"\"\"Get a document by ID\"\"\"\n        ...\n\n    @classmethod\n    def count(cls, filter=None, **kwargs) -&gt; int:\n        \"\"\"Return a count of documents matching the filter\"\"\"\n        ...\n\n    @classmethod\n    def ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n        \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n        ...\n\n    @classmethod\n    def one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n        \"\"\"Return the first spec object matching the filter\"\"\"\n        ...\n\n    @classmethod\n    def many(cls, filter=None, **kwargs) -&gt; list[Self]:\n        \"\"\"Return a list of spec objects matching the filter\"\"\"\n        ...\n\n    @classmethod\n    def get_collection(cls) -&gt; Collection[Any]:\n        \"\"\"Return a reference to the database collection for the class\"\"\"\n        ...\n\n    @classmethod\n    def get_db(cls) -&gt; Database:\n        \"\"\"Return the database for the collection\"\"\"\n        ...\n\n    @classmethod\n    @contextmanager\n    def with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]: ...\n\n    @classmethod\n    def _path_to_value(cls, path: str, parent_dict: dict[str, Any]) -&gt; Any:\n        \"\"\"Return a value from a dictionary at the given path\"\"\"\n        ...\n\n    @classmethod\n    def _path_to_keys(cls, path: str) -&gt; list[str]:\n        \"\"\"Return a list of keys for a given path\"\"\"\n        ...\n\n    @classmethod\n    def _ensure_frames(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n        \"\"\"\n        Ensure all items in a list are frames by converting those that aren't.\n        \"\"\"\n        ...\n\n    @classmethod\n    def _apply_sub_frames(cls, documents: RawDocuments, subs: dict[str, Any]) -&gt; None:\n        \"\"\"Convert embedded documents to sub-frames for one or more documents\"\"\"\n        ...\n\n    @classmethod\n    def _flatten_projection(cls, projection: dict[str, Any]) -&gt; tuple[dict[str, Any], dict[str, Any], dict[str, Any]]:\n        \"\"\"\n        Flatten a structured projection (structure projections support for\n        projections of (to be) dereferenced fields.\n        \"\"\"\n        ...\n\n    @classmethod\n    def _dereference(cls, documents: RawDocuments, references: dict[str, Any]):\n        \"\"\"Dereference one or more documents\"\"\"\n        ...\n\n    # Signals\n    @classmethod\n    def listen(cls, event: str, func: Callable) -&gt; None:\n        \"\"\"Add a callback for a signal against the class\"\"\"\n        ...\n\n    @classmethod\n    def stop_listening(cls, event: str, func: Callable) -&gt; None:\n        \"\"\"Remove a callback for a signal against the class\"\"\"\n        ...\n\n    # Integrity helpers\n\n    @classmethod\n    def cascade(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n        ...\n\n    @classmethod\n    def nullify(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n        ...\n\n    @classmethod\n    def pull(cls, ref_cls, field, frames) -&gt; None:\n        \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n        ...\n\n    def __eq__(self, other: Any) -&gt; bool: ...\n\n    def __lt__(self, other: Any) -&gt; Any: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Self\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; Self: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_json_type(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SpecProtocol.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]: ...\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SubSpecBase","title":"SubSpecBase","text":"Source code in <code>mongospecs/base.py</code> <pre><code>class SubSpecBase:\n    _parent: ClassVar[Any] = SpecBase\n\n    def to_dict(self) -&gt; Any:\n        raise NotImplementedError()\n\n    @classmethod\n    def _apply_projection(cls, documents, projection):\n        # Find reference and sub-frame mappings\n        references = {}\n        subs = {}\n        for key, value in deepcopy(projection).items():\n            if not isinstance(value, dict):\n                continue\n\n            # Store a reference/sub-frame projection\n            if \"$ref\" in value:\n                references[key] = value\n            elif \"$sub\" in value or \"$sub.\" in value:\n                subs[key] = value\n\n        # Dereference the documents (if required)\n        if references:\n            cls._parent._dereference(documents, references)\n\n        # Add sub-frames to the documents (if required)\n        if subs:\n            cls._parent._apply_sub_frames(documents, subs)\n\n    @classmethod\n    def _projection_to_paths(cls, root_key, projection):\n        \"\"\"\n        Expand a $sub/$sub. projection to a single projection of True (if\n        inclusive) or a map of full paths (e.g `employee.company.tel`).\n        \"\"\"\n\n        # Referenced projections are handled separately so just flag the\n        # reference field to true.\n        if \"$ref\" in projection:\n            return True\n\n        inclusive = True\n        sub_projection = {}\n        for key, value in projection.items():\n            if key in [\"$sub\", \"$sub.\"]:\n                continue\n\n            if key.startswith(\"$\"):\n                sub_projection[root_key] = {key: value}\n                inclusive = False\n                continue\n\n            sub_key = root_key + \".\" + key\n\n            if isinstance(value, dict):\n                sub_value = cls._projection_to_paths(sub_key, value)\n                if isinstance(sub_value, dict):\n                    sub_projection.update(sub_value)\n                else:\n                    sub_projection[sub_key] = True\n\n            else:\n                sub_projection[sub_key] = True\n                inclusive = False\n\n        if inclusive:\n            # No specific keys so this is inclusive\n            return True\n\n        return sub_projection\n</code></pre>"},{"location":"reference/base/#mongospecs.base.SubSpecBase.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_dict(self) -&gt; Any:\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/base/#mongospecs.base.to_refs","title":"to_refs","text":"<pre><code>to_refs(value: Any) -&gt; Any\n</code></pre> <p>Convert all Frame instances within the given value to Ids</p> Source code in <code>mongospecs/base.py</code> <pre><code>def to_refs(value: Any) -&gt; Any:\n    \"\"\"Convert all Frame instances within the given value to Ids\"\"\"\n    # Frame\n    if isinstance(value, SpecBase):\n        return getattr(value, \"_id\")\n\n    # SubFrame\n    elif isinstance(value, SubSpecBase):\n        return to_refs(value.to_dict())\n\n    # Lists\n    elif isinstance(value, (list, tuple)):\n        return [to_refs(v) for v in value]\n\n    # Dictionaries\n    elif isinstance(value, dict):\n        return {k: to_refs(v) for k, v in value.items()}\n\n    return value\n</code></pre>"},{"location":"reference/empty/","title":"empty","text":""},{"location":"reference/empty/#mongospecs.empty","title":"empty","text":""},{"location":"reference/empty/#mongospecs.empty.Empty","title":"Empty  <code>module-attribute</code>","text":"<pre><code>Empty = EmptyObject()\n</code></pre>"},{"location":"reference/empty/#mongospecs.empty.EmptyObject","title":"EmptyObject","text":"<p>             Bases: <code>str</code></p> Source code in <code>mongospecs/empty.py</code> <pre><code>class EmptyObject(str):\n    def __repr__(self):\n        return \"Empty\"\n\n    def __bool__(self):\n        return False\n\n    def __str__(self):\n        return \"Empty\"\n</code></pre>"},{"location":"reference/msgspec/","title":"msgspec","text":""},{"location":"reference/msgspec/#mongospecs.msgspec","title":"msgspec","text":""},{"location":"reference/msgspec/#mongospecs.msgspec.SpecAdapter","title":"SpecAdapter  <code>module-attribute</code>","text":"<pre><code>SpecAdapter = AdapterBuilder()\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.AdapterBuilder","title":"AdapterBuilder","text":"Source code in <code>mongospecs/msgspec.py</code> <pre><code>class AdapterBuilder:\n    def __call__(\n        self, obj: type[msgspec.Struct], *, collection: str, client: Optional[MongoClient] = None, **kwds: Any\n    ) -&gt; Any:\n        class BuiltSpecAdapter(SpecBase, obj):  # type: ignore\n            _id: Union[EmptyObject, ObjectId] = msgspec.field(default=Empty)\n            _empty_type: ClassVar[Any] = msgspec.UNSET\n\n            def encode(self, **encode_kwargs: Any) -&gt; bytes:\n                return msgspec.json.encode(self, **encode_kwargs) if encode_kwargs else MongoEncoder.encode(self)\n\n            def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n                return msgspec.json.decode(data, type=self.__class__, dec_hook=mongo_dec_hook, **decode_kwargs)\n\n            def to_json_type(self) -&gt; Any:\n                return msgspec.to_builtins(self, enc_hook=mongo_enc_hook)\n\n            def to_dict(self) -&gt; dict[str, Any]:\n                return msgspec.structs.asdict(self)\n\n            def to_tuple(self) -&gt; tuple[Any, ...]:\n                return msgspec.structs.astuple(self)\n\n            @classmethod\n            def get_fields(cls) -&gt; set[str]:\n                return set(cls.__struct_fields__)\n\n            # msgspec Struct includes these by default- so we need to override them\n            def __eq__(self, other: Any) -&gt; bool:\n                if not isinstance(other, self.__class__):\n                    return False\n\n                return self._id == other._id\n\n            def __lt__(self, other: Any) -&gt; Any:\n                return self._id &lt; other._id\n\n        BuiltSpecAdapter.__name__ = f\"{obj.__name__}SpecAdapter\"\n        BuiltSpecAdapter._collection = collection\n        BuiltSpecAdapter.__doc__ = obj.__doc__\n        if client:\n            BuiltSpecAdapter._client = client\n        return BuiltSpecAdapter\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter","title":"MsgspecAdapter","text":"<p>             Bases: <code>SpecProtocol</code></p> Source code in <code>mongospecs/msgspec.py</code> <pre><code>class MsgspecAdapter(SpecProtocol):\n    _id: Union[EmptyObject, ObjectId] = msgspec.field(default=Empty)\n    _empty_type: ClassVar[Any] = msgspec.UNSET\n\n    def __init__(self, **data: Any) -&gt; None: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Self\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; Self: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_json_type(self) -&gt; dict[str, Any]: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.MsgspecAdapter.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]: ...\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec","title":"Spec","text":"<p>             Bases: <code>Struct</code>, <code>SpecBase</code></p> Source code in <code>mongospecs/msgspec.py</code> <pre><code>class Spec(msgspec.Struct, SpecBase, kw_only=True):\n    _id: Union[ObjectId, msgspec.UnsetType] = msgspec.field(name=\"_id\", default=msgspec.UNSET)  # type: ignore[assignment]\n    _empty_type: ClassVar[Any] = msgspec.UNSET\n\n    def encode(self, **encode_kwargs: Any) -&gt; bytes:\n        return msgspec.json.encode(self, **encode_kwargs) if encode_kwargs else MongoEncoder.encode(self)\n\n    def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n        return msgspec.json.decode(data, type=self.__class__, dec_hook=mongo_dec_hook, **decode_kwargs)\n\n    def to_json_type(self) -&gt; Any:\n        return msgspec.to_builtins(self, enc_hook=mongo_enc_hook)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return msgspec.structs.asdict(self)\n\n    def to_tuple(self) -&gt; tuple[Any, ...]:\n        return msgspec.structs.astuple(self)\n\n    @classmethod\n    def get_fields(cls) -&gt; set[str]:\n        return set(cls.__struct_fields__)\n\n    # msgspec Struct includes these by default- so we need to override them\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, self.__class__):\n            return False\n\n        return self._id == other._id\n\n    def __lt__(self, other: Any) -&gt; Any:\n        return self._id &lt; other._id\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    return cls.one({\"_id\": id}, **kwargs)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n    ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    filter = to_refs(filter)\n\n    if filter:\n        return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n    else:\n        return cls.get_collection().estimated_document_count(**kwargs)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n    return msgspec.json.decode(data, type=self.__class__, dec_hook=mongo_dec_hook, **decode_kwargs)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n\n    assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n    # Send delete signal\n    signal(\"delete\").send(self.__class__, frames=[self])\n\n    # Delete the document\n    self.get_collection().delete_one({\"_id\": self._id})\n\n    # Send deleted signal\n    signal(\"deleted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n    # Send delete signal\n    signal(\"delete\").send(cls, frames=frames)\n\n    # Prepare the documents to be deleted\n    ids = [f._id for f in frames]\n\n    # Delete the documents\n    cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    # Send deleted signal\n    signal(\"deleted\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes:\n    return msgspec.json.encode(self, **encode_kwargs) if encode_kwargs else MongoEncoder.encode(self)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Make sure we found documents\n    if not documents:\n        return []\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return documents\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return {}\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return document\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Self\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; Self:\n    return cls(**document)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.from_raw_bson","title":"from_raw_bson  <code>classmethod</code>","text":"<pre><code>from_raw_bson(raw_bson) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_raw_bson(cls, raw_bson) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    if cls._collection_context is not None:\n        return cls._collection_context\n\n    return getattr(cls.get_db(), cls._collection or cls.__name__)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    if not cls._client:\n        raise NotImplementedError(\"_client is not setup yet\")\n    if cls._db is not None:\n        return getattr(cls._client, cls._db.name)\n    return cls._client.get_default_database()\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]:\n    return set(cls.__struct_fields__)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n    return [d[\"_id\"] for d in list(documents)]\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    # Send insert signal\n    signal(\"insert\").send(self.__class__, frames=[self])\n\n    document_dict = self.to_dict()\n    if not self._id:\n        document_dict.pop(\"_id\", None)\n    # Prepare the document to be inserted\n    document = to_refs(document_dict)\n\n    # Insert the document and update the Id\n    self._id = self.get_collection().insert_one(document).inserted_id\n\n    # Send inserted signal\n    signal(\"inserted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    # Send insert signal\n    signal(\"insert\").send(cls, frames=frames)\n\n    # Prepare the documents to be inserted\n    _documents = [to_refs(f.to_dict()) for f in frames]\n\n    for _document in _documents:\n        if not _document[\"_id\"]:\n            _document.pop(\"_id\")\n\n    # Bulk insert\n    ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n    # Apply the Ids to the frames\n    for i, id in enumerate(ids):\n        frames[i]._id = id\n\n    # Send inserted signal\n    signal(\"inserted\").send(cls, frames=frames)\n\n    return frames\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    signal(event).connect(func, sender=cls)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return [cls(**d) for d in documents]\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return None\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return cls.from_document(document)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    frame = self.find_one({\"_id\": self._id}, **kwargs)\n    for field in frame:\n        setattr(self, field, frame[field])\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    signal(event).disconnect(func, sender=cls)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return msgspec.structs.asdict(self)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; Any\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def to_json_type(self) -&gt; Any:\n    return msgspec.to_builtins(self, enc_hook=mongo_enc_hook)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]:\n    return msgspec.structs.astuple(self)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Clear the fields from the document and build the unset object\n    unset = {}\n    for field in fields:\n        setattr(self, field, self._empty_type)\n        unset[field] = True\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Clear the fields from the documents and build a list of ids to\n    # update.\n    ids = []\n    for frame in frames:\n        if frame._id:\n            ids.append(frame._id)\n\n    # Build the unset object\n    unset = {}\n    for field in fields:\n        unset[field] = True\n        for frame in frames:\n            frame.to_dict().pop(field, None)\n\n    # Update the document\n    cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    self_document = self.to_dict()\n    assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        document = {}\n        for field in fields:\n            document[field] = self._path_to_value(field, self_document)\n    else:\n        document = self_document\n\n    # Prepare the document to be updated\n    document = to_refs(document)\n    document.pop(\"_id\", None)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Prepare the documents to be updated\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        _documents = []\n        for frame in frames:\n            document = {\"_id\": frame._id}\n            for field in fields:\n                document[field] = cls._path_to_value(field, frame.to_dict())\n            _documents.append(to_refs(document))\n    else:\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n    # Update the documents\n    requests = []\n    for _document in _documents:\n        _id = _document.pop(\"_id\")\n        requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n    cls.get_collection().bulk_write(requests)\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n\n    # If no `_id` is provided then we insert the document\n    if not self._id:\n        return self.insert()\n\n    # If an `_id` is provided then we need to check if it exists before\n    # performing the `upsert`.\n    #\n    if self.count({\"_id\": self._id}) == 0:\n        self.insert()\n    else:\n        self.update(*fields)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.Spec.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n    existing_context = getattr(cls, \"_collection_context\", None)\n\n    try:\n        collection = cls.get_collection()\n        cls._collection_context = collection.with_options(**options)\n        yield cls._collection_context\n\n    finally:\n        if cls._collection_context is None:\n            del cls._collection_context\n        else:\n            cls._collection_context = existing_context\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.SubSpec","title":"SubSpec","text":"<p>             Bases: <code>Struct</code>, <code>SubSpecBase</code></p> Source code in <code>mongospecs/msgspec.py</code> <pre><code>class SubSpec(msgspec.Struct, SubSpecBase, kw_only=True, dict=True):\n    _parent: ClassVar[Any] = Spec\n\n    def get(self, name, default=None):  # -&gt; Any:\n        return self.to_dict().get(name, default)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return msgspec.structs.asdict(self)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.SubSpec.get","title":"get","text":"<pre><code>get(name, default=None)\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def get(self, name, default=None):  # -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/msgspec/#mongospecs.msgspec.SubSpec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/msgspec.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return msgspec.structs.asdict(self)\n</code></pre>"},{"location":"reference/ops/","title":"ops","text":""},{"location":"reference/ops/#mongospecs.ops","title":"ops","text":""},{"location":"reference/ops/#mongospecs.ops.And","title":"And","text":"<p>             Bases: <code>Group</code></p> <p>And performs a logical AND operation on a list of two or more conditions and selects the documents that satisfy all the conditions.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>class And(Group):\n    \"\"\"\n    And performs a logical AND operation on a list of two or more conditions and\n    selects the documents that satisfy all the conditions.\n    \"\"\"\n\n    operator = \"$and\"\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.And.conditions","title":"conditions  <code>instance-attribute</code>","text":"<pre><code>conditions = conditions\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.And.operator","title":"operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operator = '$and'\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.And.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary suitable for use with pymongo as a filter</p> Source code in <code>mongospecs/query.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n    raw_conditions = []\n    for condition in self.conditions:\n        if isinstance(condition, (Condition, Group)):\n            raw_conditions.append(condition.to_dict())\n        else:\n            raw_conditions.append(condition)\n    return {self.operator: raw_conditions}\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Nor","title":"Nor","text":"<p>             Bases: <code>Group</code></p> <p>Nor performs a logical NOR operation on a list of one or more conditions and selects the documents that fail all the conditions.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>class Nor(Group):\n    \"\"\"\n    Nor performs a logical NOR operation on a list of one or more conditions and\n    selects the documents that fail all the conditions.\n    \"\"\"\n\n    operator = \"$nor\"\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Nor.conditions","title":"conditions  <code>instance-attribute</code>","text":"<pre><code>conditions = conditions\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Nor.operator","title":"operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operator = '$nor'\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Nor.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary suitable for use with pymongo as a filter</p> Source code in <code>mongospecs/query.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n    raw_conditions = []\n    for condition in self.conditions:\n        if isinstance(condition, (Condition, Group)):\n            raw_conditions.append(condition.to_dict())\n        else:\n            raw_conditions.append(condition)\n    return {self.operator: raw_conditions}\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Or","title":"Or","text":"<p>             Bases: <code>Group</code></p> <p>The Or operator performs a logical OR operation on a list of two or more conditions and selects the documents that satisfy at least one of the conditions.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>class Or(Group):\n    \"\"\"\n    The Or operator performs a logical OR operation on a list of two or more\n    conditions and selects the documents that satisfy at least one of the\n    conditions.\n    \"\"\"\n\n    operator = \"$or\"\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Or.conditions","title":"conditions  <code>instance-attribute</code>","text":"<pre><code>conditions = conditions\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Or.operator","title":"operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operator = '$or'\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Or.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary suitable for use with pymongo as a filter</p> Source code in <code>mongospecs/query.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n    raw_conditions = []\n    for condition in self.conditions:\n        if isinstance(condition, (Condition, Group)):\n            raw_conditions.append(condition.to_dict())\n        else:\n            raw_conditions.append(condition)\n    return {self.operator: raw_conditions}\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.All","title":"All","text":"<pre><code>All(q, value)\n</code></pre> <p>The All operator selects documents where the value of the field is an list that contains all the specified elements.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def All(q, value):\n    \"\"\"\n    The All operator selects documents where the value of the field is an list\n    that contains all the specified elements.\n    \"\"\"\n    return Condition(q._path, to_refs(value), \"$all\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.ElemMatch","title":"ElemMatch","text":"<pre><code>ElemMatch(q, *conditions)\n</code></pre> <p>The ElemMatch operator matches documents that contain an array field with at least one element that matches all the specified query criteria.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def ElemMatch(q, *conditions):\n    \"\"\"\n    The ElemMatch operator matches documents that contain an array field with at\n    least one element that matches all the specified query criteria.\n    \"\"\"\n    new_condition = {}\n    for condition in conditions:\n        if isinstance(condition, (Condition, Group)):\n            condition = condition.to_dict()\n\n        deep_merge(condition, new_condition)\n\n    return Condition(q._path, new_condition, \"$elemMatch\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Exists","title":"Exists","text":"<pre><code>Exists(q, value)\n</code></pre> <p>When exists is True, Exists matches the documents that contain the field, including documents where the field value is null. If exists is False, the query returns only the documents that do not contain the field.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def Exists(q, value):\n    \"\"\"\n    When exists is True, Exists matches the documents that contain the field,\n    including documents where the field value is null. If exists is False, the\n    query returns only the documents that do not contain the field.\n    \"\"\"\n    return Condition(q._path, value, \"$exists\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.In","title":"In","text":"<pre><code>In(q, value)\n</code></pre> <p>The In operator selects the documents where the value of a field equals any value in the specified list.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def In(q, value):\n    \"\"\"\n    The In operator selects the documents where the value of a field equals any\n    value in the specified list.\n    \"\"\"\n    return Condition(q._path, to_refs(value), \"$in\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Not","title":"Not","text":"<pre><code>Not(condition)\n</code></pre> <p>Not performs a logical NOT operation on the specified condition and selects the documents that do not match. This includes documents that do not contain the field.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def Not(condition):\n    \"\"\"\n    Not performs a logical NOT operation on the specified condition and selects\n    the documents that do not match. This includes documents that do not contain\n    the field.\n    \"\"\"\n    return Condition(condition.q, {condition.operator: condition.value}, \"$not\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.NotIn","title":"NotIn","text":"<pre><code>NotIn(q, value)\n</code></pre> <p>The NotIn operator selects documents where the field value is not in the specified list or the field does not exists.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def NotIn(q, value):\n    \"\"\"\n    The NotIn operator selects documents where the field value is not in the\n    specified list or the field does not exists.\n    \"\"\"\n    return Condition(q._path, to_refs(value), \"$nin\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Size","title":"Size","text":"<pre><code>Size(q, value)\n</code></pre> <p>The Size operator matches any list with the number of elements specified by size.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def Size(q, value):\n    \"\"\"\n    The Size operator matches any list with the number of elements specified by\n    size.\n    \"\"\"\n    return Condition(q._path, value, \"$size\")\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.SortBy","title":"SortBy","text":"<pre><code>SortBy(*qs)\n</code></pre> <p>Convert a list of Q objects into list of sort instructions</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def SortBy(*qs):\n    \"\"\"Convert a list of Q objects into list of sort instructions\"\"\"\n\n    sort = []\n    for q in qs:\n        if q._path.endswith(\".desc\"):\n            sort.append((q._path[:-5], DESCENDING))\n        else:\n            sort.append((q._path, ASCENDING))\n    return sort\n</code></pre>"},{"location":"reference/ops/#mongospecs.ops.Type","title":"Type","text":"<pre><code>Type(q, value)\n</code></pre> <p>Type selects documents where the value of the field is an instance of the specified BSON type.</p> Source code in <code>mongospecs/ops.py</code> <pre><code>def Type(q, value):\n    \"\"\"\n    Type selects documents where the value of the field is an instance of the\n    specified BSON type.\n    \"\"\"\n    return Condition(q._path, value, \"$type\")\n</code></pre>"},{"location":"reference/pydantic/","title":"pydantic","text":""},{"location":"reference/pydantic/#mongospecs.pydantic","title":"pydantic","text":""},{"location":"reference/pydantic/#mongospecs.pydantic.PyObjectId","title":"PyObjectId  <code>module-attribute</code>","text":"<pre><code>PyObjectId = Annotated[ObjectId, _ObjectIdPydanticAnnotation]\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.SpecAdapter","title":"SpecAdapter  <code>module-attribute</code>","text":"<pre><code>SpecAdapter = AdapterBuilder()\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=PydanticAdapter)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.AdapterBuilder","title":"AdapterBuilder","text":"Source code in <code>mongospecs/pydantic.py</code> <pre><code>class AdapterBuilder:\n    def __call__(\n        self, obj: type[BaseModel], *, collection: str, client: Optional[MongoClient] = None, **kwds: Any\n    ) -&gt; Any:\n        class BuiltSpecAdapter(obj, Spec):  # type: ignore\n            pass\n\n        BuiltSpecAdapter.__name__ = f\"{obj.__name__}SpecAdapter\"\n        BuiltSpecAdapter._collection = collection\n        BuiltSpecAdapter.__doc__ = obj.__doc__\n        if client:\n            BuiltSpecAdapter._client = client\n        return BuiltSpecAdapter\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter","title":"PydanticAdapter","text":"<p>             Bases: <code>Spec</code>, <code>BaseModel</code></p> Source code in <code>mongospecs/pydantic.py</code> <pre><code>class PydanticAdapter(Spec, BaseModel):\n    def __init__(self, **data: Any) -&gt; None:\n        \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n        Raises [ValidationError][pydantic_core.ValidationError] if the input data cannot\n        be validated to form a valid model.\n\n        __init__ uses __pydantic_self__ instead of the more common self for the first arg\n        to allow self as a field name.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[PyObjectId] = Field(default=None, alias='_id')\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    return cls.one({\"_id\": id}, **kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n    ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    filter = to_refs(filter)\n\n    if filter:\n        return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n    else:\n        return cls.get_collection().estimated_document_count(**kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n    return self.__class__.model_validate_json(data, **decode_kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n\n    assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n    # Send delete signal\n    signal(\"delete\").send(self.__class__, frames=[self])\n\n    # Delete the document\n    self.get_collection().delete_one({\"_id\": self._id})\n\n    # Send deleted signal\n    signal(\"deleted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n    # Send delete signal\n    signal(\"delete\").send(cls, frames=frames)\n\n    # Prepare the documents to be deleted\n    ids = [f._id for f in frames]\n\n    # Delete the documents\n    cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    # Send deleted signal\n    signal(\"deleted\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes:\n    return str.encode(self.model_dump_json(**encode_kwargs))\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Make sure we found documents\n    if not documents:\n        return []\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return documents\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return {}\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return document\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Spec\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; \"Spec\":\n    return cls.model_construct(**document)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.from_raw_bson","title":"from_raw_bson  <code>classmethod</code>","text":"<pre><code>from_raw_bson(raw_bson) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_raw_bson(cls, raw_bson) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    if cls._collection_context is not None:\n        return cls._collection_context\n\n    return getattr(cls.get_db(), cls._collection or cls.__name__)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    if not cls._client:\n        raise NotImplementedError(\"_client is not setup yet\")\n    if cls._db is not None:\n        return getattr(cls._client, cls._db.name)\n    return cls._client.get_default_database()\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]:\n    return set(cls.model_fields.keys())\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n    return [d[\"_id\"] for d in list(documents)]\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    # Send insert signal\n    signal(\"insert\").send(self.__class__, frames=[self])\n\n    document_dict = self.to_dict()\n    if not self._id:\n        document_dict.pop(\"_id\", None)\n    # Prepare the document to be inserted\n    document = to_refs(document_dict)\n\n    # Insert the document and update the Id\n    self._id = self.get_collection().insert_one(document).inserted_id\n\n    # Send inserted signal\n    signal(\"inserted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    # Send insert signal\n    signal(\"insert\").send(cls, frames=frames)\n\n    # Prepare the documents to be inserted\n    _documents = [to_refs(f.to_dict()) for f in frames]\n\n    for _document in _documents:\n        if not _document[\"_id\"]:\n            _document.pop(\"_id\")\n\n    # Bulk insert\n    ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n    # Apply the Ids to the frames\n    for i, id in enumerate(ids):\n        frames[i]._id = id\n\n    # Send inserted signal\n    signal(\"inserted\").send(cls, frames=frames)\n\n    return frames\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    signal(event).connect(func, sender=cls)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return [cls(**d) for d in documents]\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return None\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return cls.from_document(document)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    frame = self.find_one({\"_id\": self._id}, **kwargs)\n    for field in frame:\n        setattr(self, field, frame[field])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    signal(event).disconnect(func, sender=cls)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    copy_dict = self.__dict__.copy()\n    copy_dict[\"_id\"] = copy_dict.pop(\"id\")\n    return copy_dict\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; Any\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def to_json_type(self) -&gt; Any:\n    return self.model_dump(mode=\"json\", by_alias=True, exclude_unset=True)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Clear the fields from the document and build the unset object\n    unset = {}\n    for field in fields:\n        setattr(self, field, self._empty_type)\n        unset[field] = True\n\n        ## pydantic specific change:\n        ## remove from model fields set so it excludes when `to_json_type` is called\n        self.model_fields_set.remove(field)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Clear the fields from the documents and build a list of ids to\n    # update.\n    ids = []\n    for frame in frames:\n        if frame._id:\n            ids.append(frame._id)\n\n    # Build the unset object\n    unset = {}\n    for field in fields:\n        unset[field] = True\n        for frame in frames:\n            frame.to_dict().pop(field, None)\n\n    # Update the document\n    cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    self_document = self.to_dict()\n    assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        document = {}\n        for field in fields:\n            document[field] = self._path_to_value(field, self_document)\n    else:\n        document = self_document\n\n    # Prepare the document to be updated\n    document = to_refs(document)\n    document.pop(\"_id\", None)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Prepare the documents to be updated\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        _documents = []\n        for frame in frames:\n            document = {\"_id\": frame._id}\n            for field in fields:\n                document[field] = cls._path_to_value(field, frame.to_dict())\n            _documents.append(to_refs(document))\n    else:\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n    # Update the documents\n    requests = []\n    for _document in _documents:\n        _id = _document.pop(\"_id\")\n        requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n    cls.get_collection().bulk_write(requests)\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n\n    # If no `_id` is provided then we insert the document\n    if not self._id:\n        return self.insert()\n\n    # If an `_id` is provided then we need to check if it exists before\n    # performing the `upsert`.\n    #\n    if self.count({\"_id\": self._id}) == 0:\n        self.insert()\n    else:\n        self.update(*fields)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.PydanticAdapter.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n    existing_context = getattr(cls, \"_collection_context\", None)\n\n    try:\n        collection = cls.get_collection()\n        cls._collection_context = collection.with_options(**options)\n        yield cls._collection_context\n\n    finally:\n        if cls._collection_context is None:\n            del cls._collection_context\n        else:\n            cls._collection_context = existing_context\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec","title":"Spec","text":"<p>             Bases: <code>BaseModel</code>, <code>SpecBase</code></p> Source code in <code>mongospecs/pydantic.py</code> <pre><code>class Spec(BaseModel, SpecBase):\n    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)\n\n    id: Optional[PyObjectId] = Field(default=None, alias=\"_id\")\n\n    @classmethod\n    def from_document(cls, document: dict[str, Any]) -&gt; \"Spec\":\n        return cls.model_construct(**document)\n\n    @property\n    def _id(self) -&gt; Union[EmptyObject, ObjectId]:\n        return cast(Union[EmptyObject, ObjectId], self.id)\n\n    @_id.setter\n    def _id(self, value: ObjectId) -&gt; None:\n        self.id = value\n\n    def unset(self, *fields: Any) -&gt; None:\n        \"\"\"Unset the given list of fields for this document.\"\"\"\n\n        # Send update signal\n        signal(\"update\").send(self.__class__, frames=[self])\n\n        # Clear the fields from the document and build the unset object\n        unset = {}\n        for field in fields:\n            setattr(self, field, self._empty_type)\n            unset[field] = True\n\n            ## pydantic specific change:\n            ## remove from model fields set so it excludes when `to_json_type` is called\n            self.model_fields_set.remove(field)\n\n        # Update the document\n        self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n        # Send updated signal\n        signal(\"updated\").send(self.__class__, frames=[self])\n\n    def encode(self, **encode_kwargs: Any) -&gt; bytes:\n        return str.encode(self.model_dump_json(**encode_kwargs))\n\n    def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n        return self.__class__.model_validate_json(data, **decode_kwargs)\n\n    def to_json_type(self) -&gt; Any:\n        return self.model_dump(mode=\"json\", by_alias=True, exclude_unset=True)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        copy_dict = self.__dict__.copy()\n        copy_dict[\"_id\"] = copy_dict.pop(\"id\")\n        return copy_dict\n\n    # note: pydantic BaseModel already has to_tuple\n\n    @classmethod\n    def get_fields(cls) -&gt; set[str]:\n        return set(cls.model_fields.keys())\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[PyObjectId] = Field(default=None, alias='_id')\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.by_id","title":"by_id  <code>classmethod</code>","text":"<pre><code>by_id(id, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Get a document by ID</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef by_id(cls, id, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Get a document by ID\"\"\"\n    return cls.one({\"_id\": id}, **kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.cascade","title":"cascade  <code>classmethod</code>","text":"<pre><code>cascade(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Apply a cascading delete (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef cascade(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Apply a cascading delete (does not emit signals)\"\"\"\n    ids = [to_refs(getattr(f, field)) for f in frames if hasattr(f, field)]\n    ref_cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.count","title":"count  <code>classmethod</code>","text":"<pre><code>count(filter=None, **kwargs) -&gt; int\n</code></pre> <p>Return a count of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef count(cls, filter=None, **kwargs) -&gt; int:\n    \"\"\"Return a count of documents matching the filter\"\"\"\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    filter = to_refs(filter)\n\n    if filter:\n        return cls.get_collection().count_documents(to_refs(filter), **kwargs)\n    else:\n        return cls.get_collection().estimated_document_count(**kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.decode","title":"decode","text":"<pre><code>decode(data: Any, **decode_kwargs: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def decode(self, data: Any, **decode_kwargs: Any) -&gt; Any:\n    return self.__class__.model_validate_json(data, **decode_kwargs)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.delete","title":"delete","text":"<pre><code>delete() -&gt; None\n</code></pre> <p>Delete this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this document\"\"\"\n\n    assert \"_id\" in self.to_dict(), \"Can't delete documents without `_id`\"\n\n    # Send delete signal\n    signal(\"delete\").send(self.__class__, frames=[self])\n\n    # Delete the document\n    self.get_collection().delete_one({\"_id\": self._id})\n\n    # Send deleted signal\n    signal(\"deleted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.delete_many","title":"delete_many  <code>classmethod</code>","text":"<pre><code>delete_many(documents: SpecsOrRawDocuments) -&gt; None\n</code></pre> <p>Delete multiple documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef delete_many(cls, documents: SpecsOrRawDocuments) -&gt; None:\n    \"\"\"Delete multiple documents\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't delete documents without `_id`s\"\n\n    # Send delete signal\n    signal(\"delete\").send(cls, frames=frames)\n\n    # Prepare the documents to be deleted\n    ids = [f._id for f in frames]\n\n    # Delete the documents\n    cls.get_collection().delete_many({\"_id\": {\"$in\": ids}})\n\n    # Send deleted signal\n    signal(\"deleted\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.encode","title":"encode","text":"<pre><code>encode(**encode_kwargs: Any) -&gt; bytes\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def encode(self, **encode_kwargs: Any) -&gt; bytes:\n    return str.encode(self.model_dump_json(**encode_kwargs))\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.find","title":"find  <code>classmethod</code>","text":"<pre><code>find(filter=None, **kwargs) -&gt; list[Mapping[str, Any]]\n</code></pre> <p>Return a list of documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find(cls, filter=None, **kwargs) -&gt; list[Mapping[str, Any]]:\n    \"\"\"Return a list of documents matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Make sure we found documents\n    if not documents:\n        return []\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return documents\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.find_one","title":"find_one  <code>classmethod</code>","text":"<pre><code>find_one(filter=None, **kwargs) -&gt; Mapping[str, Any]\n</code></pre> <p>Return the first document matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef find_one(cls, filter=None, **kwargs) -&gt; Mapping[str, Any]:\n    \"\"\"Return the first document matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return {}\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return document\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.from_document","title":"from_document  <code>classmethod</code>","text":"<pre><code>from_document(document: dict[str, Any]) -&gt; Spec\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>@classmethod\ndef from_document(cls, document: dict[str, Any]) -&gt; \"Spec\":\n    return cls.model_construct(**document)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.from_raw_bson","title":"from_raw_bson  <code>classmethod</code>","text":"<pre><code>from_raw_bson(raw_bson) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef from_raw_bson(cls, raw_bson) -&gt; Any:\n    pass\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.get","title":"get","text":"<pre><code>get(name, default=None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def get(self, name, default=None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.get_collection","title":"get_collection  <code>classmethod</code>","text":"<pre><code>get_collection() -&gt; Collection[Any]\n</code></pre> <p>Return a reference to the database collection for the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_collection(cls) -&gt; Collection[Any]:\n    \"\"\"Return a reference to the database collection for the class\"\"\"\n    if cls._collection_context is not None:\n        return cls._collection_context\n\n    return getattr(cls.get_db(), cls._collection or cls.__name__)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.get_db","title":"get_db  <code>classmethod</code>","text":"<pre><code>get_db() -&gt; Database\n</code></pre> <p>Return the database for the collection</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef get_db(cls) -&gt; Database:\n    \"\"\"Return the database for the collection\"\"\"\n    if not cls._client:\n        raise NotImplementedError(\"_client is not setup yet\")\n    if cls._db is not None:\n        return getattr(cls._client, cls._db.name)\n    return cls._client.get_default_database()\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.get_fields","title":"get_fields  <code>classmethod</code>","text":"<pre><code>get_fields() -&gt; set[str]\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>@classmethod\ndef get_fields(cls) -&gt; set[str]:\n    return set(cls.model_fields.keys())\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.ids","title":"ids  <code>classmethod</code>","text":"<pre><code>ids(filter=None, **kwargs) -&gt; list[ObjectId]\n</code></pre> <p>Return a list of Ids for documents matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef ids(cls, filter=None, **kwargs) -&gt; list[ObjectId]:\n    \"\"\"Return a list of Ids for documents matching the filter\"\"\"\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = cls.get_collection().find(to_refs(filter), projection={\"_id\": True}, **kwargs)\n\n    return [d[\"_id\"] for d in list(documents)]\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.insert","title":"insert","text":"<pre><code>insert() -&gt; None\n</code></pre> <p>Insert this document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def insert(self) -&gt; None:\n    \"\"\"Insert this document\"\"\"\n    # Send insert signal\n    signal(\"insert\").send(self.__class__, frames=[self])\n\n    document_dict = self.to_dict()\n    if not self._id:\n        document_dict.pop(\"_id\", None)\n    # Prepare the document to be inserted\n    document = to_refs(document_dict)\n\n    # Insert the document and update the Id\n    self._id = self.get_collection().insert_one(document).inserted_id\n\n    # Send inserted signal\n    signal(\"inserted\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.insert_many","title":"insert_many  <code>classmethod</code>","text":"<pre><code>insert_many(documents: SpecsOrRawDocuments) -&gt; Specs\n</code></pre> <p>Insert a list of documents</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef insert_many(cls, documents: SpecsOrRawDocuments) -&gt; Specs:\n    \"\"\"Insert a list of documents\"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    # Send insert signal\n    signal(\"insert\").send(cls, frames=frames)\n\n    # Prepare the documents to be inserted\n    _documents = [to_refs(f.to_dict()) for f in frames]\n\n    for _document in _documents:\n        if not _document[\"_id\"]:\n            _document.pop(\"_id\")\n\n    # Bulk insert\n    ids = cls.get_collection().insert_many(_documents).inserted_ids\n\n    # Apply the Ids to the frames\n    for i, id in enumerate(ids):\n        frames[i]._id = id\n\n    # Send inserted signal\n    signal(\"inserted\").send(cls, frames=frames)\n\n    return frames\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.listen","title":"listen  <code>classmethod</code>","text":"<pre><code>listen(event: str, func: Callable) -&gt; None\n</code></pre> <p>Add a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef listen(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Add a callback for a signal against the class\"\"\"\n    signal(event).connect(func, sender=cls)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.many","title":"many  <code>classmethod</code>","text":"<pre><code>many(filter=None, **kwargs) -&gt; list[Self]\n</code></pre> <p>Return a list of spec objects matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef many(cls, filter=None, **kwargs) -&gt; list[Self]:\n    \"\"\"Return a list of spec objects matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the documents\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    documents = list(cls.get_collection().find(to_refs(filter), **kwargs))\n\n    # Dereference the documents (if required)\n    if references:\n        cls._dereference(documents, references)\n\n    # Add sub-frames to the documents (if required)\n    if subs:\n        cls._apply_sub_frames(documents, subs)\n\n    return [cls(**d) for d in documents]\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.nullify","title":"nullify  <code>classmethod</code>","text":"<pre><code>nullify(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Nullify a reference field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef nullify(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Nullify a reference field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$set\": {field: None}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.one","title":"one  <code>classmethod</code>","text":"<pre><code>one(filter=None, **kwargs) -&gt; Optional[Self]\n</code></pre> <p>Return the first spec object matching the filter</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef one(cls, filter=None, **kwargs) -&gt; Optional[Self]:\n    \"\"\"Return the first spec object matching the filter\"\"\"\n    # Flatten the projection\n    kwargs[\"projection\"], references, subs = cls._flatten_projection(\n        kwargs.get(\"projection\", cls._default_projection)\n    )\n\n    # Find the document\n    if isinstance(filter, (Condition, Group)):\n        filter = filter.to_dict()\n\n    document = cls.get_collection().find_one(to_refs(filter), **kwargs)\n\n    # Make sure we found a document\n    if not document:\n        return None\n\n    # Dereference the document (if required)\n    if references:\n        cls._dereference([document], references)\n\n    # Add sub-frames to the document (if required)\n    if subs:\n        cls._apply_sub_frames([document], subs)\n\n    return cls.from_document(document)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.pull","title":"pull  <code>classmethod</code>","text":"<pre><code>pull(ref_cls, field, frames) -&gt; None\n</code></pre> <p>Pull references from a list field (does not emit signals)</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef pull(cls, ref_cls, field, frames) -&gt; None:\n    \"\"\"Pull references from a list field (does not emit signals)\"\"\"\n    ids = [to_refs(f) for f in frames]\n    ref_cls.get_collection().update_many({field: {\"$in\": ids}}, {\"$pull\": {field: {\"$in\": ids}}})\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.reload","title":"reload","text":"<pre><code>reload(**kwargs)\n</code></pre> <p>Reload the document</p> Source code in <code>mongospecs/base.py</code> <pre><code>def reload(self, **kwargs):\n    \"\"\"Reload the document\"\"\"\n    frame = self.find_one({\"_id\": self._id}, **kwargs)\n    for field in frame:\n        setattr(self, field, frame[field])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.stop_listening","title":"stop_listening  <code>classmethod</code>","text":"<pre><code>stop_listening(event: str, func: Callable) -&gt; None\n</code></pre> <p>Remove a callback for a signal against the class</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef stop_listening(cls, event: str, func: Callable) -&gt; None:\n    \"\"\"Remove a callback for a signal against the class\"\"\"\n    signal(event).disconnect(func, sender=cls)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    copy_dict = self.__dict__.copy()\n    copy_dict[\"_id\"] = copy_dict.pop(\"id\")\n    return copy_dict\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.to_json_type","title":"to_json_type","text":"<pre><code>to_json_type() -&gt; Any\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def to_json_type(self) -&gt; Any:\n    return self.model_dump(mode=\"json\", by_alias=True, exclude_unset=True)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.to_tuple","title":"to_tuple","text":"<pre><code>to_tuple() -&gt; tuple[Any, ...]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>def to_tuple(self) -&gt; tuple[Any, ...]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.unset","title":"unset","text":"<pre><code>unset(*fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for this document.</p> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def unset(self, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for this document.\"\"\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Clear the fields from the document and build the unset object\n    unset = {}\n    for field in fields:\n        setattr(self, field, self._empty_type)\n        unset[field] = True\n\n        ## pydantic specific change:\n        ## remove from model fields set so it excludes when `to_json_type` is called\n        self.model_fields_set.remove(field)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.unset_many","title":"unset_many  <code>classmethod</code>","text":"<pre><code>unset_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Unset the given list of fields for given documents.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef unset_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"Unset the given list of fields for given documents.\"\"\"\n\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Clear the fields from the documents and build a list of ids to\n    # update.\n    ids = []\n    for frame in frames:\n        if frame._id:\n            ids.append(frame._id)\n\n    # Build the unset object\n    unset = {}\n    for field in fields:\n        unset[field] = True\n        for frame in frames:\n            frame.to_dict().pop(field, None)\n\n    # Update the document\n    cls.get_collection().update_many({\"_id\": {\"$in\": ids}}, {\"$unset\": unset})\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.update","title":"update","text":"<pre><code>update(*fields: Any) -&gt; None\n</code></pre> <p>Update this document. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>def update(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update this document. Optionally a specific list of fields to update can\n    be specified.\n    \"\"\"\n    self_document = self.to_dict()\n    assert \"_id\" in self_document, \"Can't update documents without `_id`\"\n\n    # Send update signal\n    signal(\"update\").send(self.__class__, frames=[self])\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        document = {}\n        for field in fields:\n            document[field] = self._path_to_value(field, self_document)\n    else:\n        document = self_document\n\n    # Prepare the document to be updated\n    document = to_refs(document)\n    document.pop(\"_id\", None)\n\n    # Update the document\n    self.get_collection().update_one({\"_id\": self._id}, {\"$set\": document})\n\n    # Send updated signal\n    signal(\"updated\").send(self.__class__, frames=[self])\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.update_many","title":"update_many  <code>classmethod</code>","text":"<pre><code>update_many(documents: SpecsOrRawDocuments, *fields: Any) -&gt; None\n</code></pre> <p>Update multiple documents. Optionally a specific list of fields to update can be specified.</p> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\ndef update_many(cls, documents: SpecsOrRawDocuments, *fields: Any) -&gt; None:\n    \"\"\"\n    Update multiple documents. Optionally a specific list of fields to\n    update can be specified.\n    \"\"\"\n    # Ensure all documents have been converted to frames\n    frames = cls._ensure_frames(documents)\n\n    all_count = len(documents)\n    assert len([f for f in frames if \"_id\" in f.to_dict()]) == all_count, \"Can't update documents without `_id`s\"\n\n    # Send update signal\n    signal(\"update\").send(cls, frames=frames)\n\n    # Prepare the documents to be updated\n\n    # Check for selective updates\n    if len(fields) &gt; 0:\n        _documents = []\n        for frame in frames:\n            document = {\"_id\": frame._id}\n            for field in fields:\n                document[field] = cls._path_to_value(field, frame.to_dict())\n            _documents.append(to_refs(document))\n    else:\n        _documents = [to_refs(f.to_dict()) for f in frames]\n\n    # Update the documents\n    requests = []\n    for _document in _documents:\n        _id = _document.pop(\"_id\")\n        requests.append(UpdateOne({\"_id\": _id}, {\"$set\": _document}))\n\n    cls.get_collection().bulk_write(requests)\n\n    # Send updated signal\n    signal(\"updated\").send(cls, frames=frames)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.upsert","title":"upsert","text":"<pre><code>upsert(*fields: Any) -&gt; None\n</code></pre> <p>Update or Insert this document depending on whether it exists or not. The presense of an <code>_id</code> value in the document is used to determine if the document exists.</p> <p>NOTE: This method is not the same as specifying the <code>upsert</code> flag when calling MongoDB. When called for a document with an <code>_id</code> value, this method will call the database to see if a record with that Id exists, if not it will call <code>insert</code>, if so it will call <code>update</code>. This operation is therefore not atomic and much slower than the equivalent MongoDB operation (due to the extra call).</p> Source code in <code>mongospecs/base.py</code> <pre><code>def upsert(self, *fields: Any) -&gt; None:\n    \"\"\"\n    Update or Insert this document depending on whether it exists or not.\n    The presense of an `_id` value in the document is used to determine if\n    the document exists.\n\n    NOTE: This method is not the same as specifying the `upsert` flag when\n    calling MongoDB. When called for a document with an `_id` value, this\n    method will call the database to see if a record with that Id exists,\n    if not it will call `insert`, if so it will call `update`. This\n    operation is therefore not atomic and much slower than the equivalent\n    MongoDB operation (due to the extra call).\n    \"\"\"\n\n    # If no `_id` is provided then we insert the document\n    if not self._id:\n        return self.insert()\n\n    # If an `_id` is provided then we need to check if it exists before\n    # performing the `upsert`.\n    #\n    if self.count({\"_id\": self._id}) == 0:\n        self.insert()\n    else:\n        self.update(*fields)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.Spec.with_options","title":"with_options  <code>classmethod</code>","text":"<pre><code>with_options(**options: Any) -&gt; Generator[Any, Any, None]\n</code></pre> Source code in <code>mongospecs/base.py</code> <pre><code>@classmethod\n@contextmanager\ndef with_options(cls, **options: Any) -&gt; Generator[Any, Any, None]:\n    existing_context = getattr(cls, \"_collection_context\", None)\n\n    try:\n        collection = cls.get_collection()\n        cls._collection_context = collection.with_options(**options)\n        yield cls._collection_context\n\n    finally:\n        if cls._collection_context is None:\n            del cls._collection_context\n        else:\n            cls._collection_context = existing_context\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.SubSpec","title":"SubSpec","text":"<p>             Bases: <code>BaseModel</code>, <code>SubSpecBase</code></p> Source code in <code>mongospecs/pydantic.py</code> <pre><code>class SubSpec(BaseModel, SubSpecBase):\n    _parent: ClassVar[Any] = Spec\n\n    def get(self, name: str, default: Any = None) -&gt; Any:\n        return self.to_dict().get(name, default)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return self.model_dump()\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.SubSpec.get","title":"get","text":"<pre><code>get(name: str, default: Any = None) -&gt; Any\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def get(self, name: str, default: Any = None) -&gt; Any:\n    return self.to_dict().get(name, default)\n</code></pre>"},{"location":"reference/pydantic/#mongospecs.pydantic.SubSpec.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>mongospecs/pydantic.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return self.model_dump()\n</code></pre>"},{"location":"reference/query/","title":"query","text":""},{"location":"reference/query/#mongospecs.query","title":"query","text":"<p>A set of helpers to simplify the creation of MongoDB queries.</p>"},{"location":"reference/query/#mongospecs.query.Condition","title":"Condition","text":"<p>A query condition of the form <code>{path: {operator: value}}</code>.</p> Source code in <code>mongospecs/query.py</code> <pre><code>class Condition:\n    \"\"\"\n    A query condition of the form `{path: {operator: value}}`.\n    \"\"\"\n\n    def __init__(self, q, value, operator):\n        self.q = q\n        self.value = value\n        self.operator = operator\n\n    def to_dict(self) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n        if self.operator == \"$eq\":\n            return {self.q: self.value}\n        if self.q is None:\n            return {self.operator: self.value}\n        return {self.q: {self.operator: self.value}}\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Condition.operator","title":"operator  <code>instance-attribute</code>","text":"<pre><code>operator = operator\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Condition.q","title":"q  <code>instance-attribute</code>","text":"<pre><code>q = q\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Condition.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = value\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Condition.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, dict[str, Any]]\n</code></pre> <p>Return a dictionary suitable for use with pymongo as a filter</p> Source code in <code>mongospecs/query.py</code> <pre><code>def to_dict(self) -&gt; dict[str, dict[str, Any]]:\n    \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n    if self.operator == \"$eq\":\n        return {self.q: self.value}\n    if self.q is None:\n        return {self.operator: self.value}\n    return {self.q: {self.operator: self.value}}\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Group","title":"Group","text":"<p>The Group class is used as a base class for operators that group together two or more conditions.</p> Source code in <code>mongospecs/query.py</code> <pre><code>class Group:\n    \"\"\"\n    The Group class is used as a base class for operators that group together\n    two or more conditions.\n    \"\"\"\n\n    operator = \"\"\n\n    def __init__(self, *conditions):\n        self.conditions = conditions\n\n    def to_dict(self):\n        \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n        raw_conditions = []\n        for condition in self.conditions:\n            if isinstance(condition, (Condition, Group)):\n                raw_conditions.append(condition.to_dict())\n            else:\n                raw_conditions.append(condition)\n        return {self.operator: raw_conditions}\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Group.conditions","title":"conditions  <code>instance-attribute</code>","text":"<pre><code>conditions = conditions\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Group.operator","title":"operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operator = ''\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Group.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Return a dictionary suitable for use with pymongo as a filter</p> Source code in <code>mongospecs/query.py</code> <pre><code>def to_dict(self):\n    \"\"\"Return a dictionary suitable for use with pymongo as a filter\"\"\"\n    raw_conditions = []\n    for condition in self.conditions:\n        if isinstance(condition, (Condition, Group)):\n            raw_conditions.append(condition.to_dict())\n        else:\n            raw_conditions.append(condition)\n    return {self.operator: raw_conditions}\n</code></pre>"},{"location":"reference/query/#mongospecs.query.Q","title":"Q","text":"<p>Start point for the query creation, the Q class is a special type of class that's typically initialized by appending an attribute, for example:</p> <pre><code>Q.hit_points &gt; 100\n</code></pre> Source code in <code>mongospecs/query.py</code> <pre><code>class Q(metaclass=QMeta):\n    \"\"\"\n    Start point for the query creation, the Q class is a special type of class\n    that's typically initialized by appending an attribute, for example:\n\n        Q.hit_points &gt; 100\n\n    \"\"\"\n\n    def __init__(self, path):\n        self._path = path\n\n    def __eq__(self, other):\n        return Condition(self._path, other, \"$eq\")\n\n    def __ge__(self, other):\n        return Condition(self._path, other, \"$gte\")\n\n    def __gt__(self, other):\n        return Condition(self._path, other, \"$gt\")\n\n    def __le__(self, other):\n        return Condition(self._path, other, \"$lte\")\n\n    def __lt__(self, other):\n        return Condition(self._path, other, \"$lt\")\n\n    def __ne__(self, other):\n        return Condition(self._path, other, \"$ne\")\n\n    def __getattr__(self, name):\n        self._path = \"{0}.{1}\".format(self._path, name)\n        return self\n\n    def __getitem__(self, name):\n        self._path = \"{0}.{1}\".format(self._path, name)\n        return self\n</code></pre>"},{"location":"reference/query/#mongospecs.query.QMeta","title":"QMeta","text":"<p>             Bases: <code>type</code></p> <p>Meta-class for query builder.</p> Source code in <code>mongospecs/query.py</code> <pre><code>class QMeta(type):\n    \"\"\"\n    Meta-class for query builder.\n    \"\"\"\n\n    def __getattr__(self, name):\n        return Q(name)\n\n    def __getitem__(self, name):\n        return Q(name)\n\n    def __eq__(self, other):\n        return Condition(None, other, \"$eq\")\n\n    def __ge__(self, other):\n        return Condition(None, other, \"$gte\")\n\n    def __gt__(self, other):\n        return Condition(None, other, \"$gt\")\n\n    def __le__(self, other):\n        return Condition(None, other, \"$lte\")\n\n    def __lt__(self, other):\n        return Condition(None, other, \"$lt\")\n\n    def __ne__(self, other):\n        return Condition(None, other, \"$ne\")\n</code></pre>"},{"location":"reference/se/","title":"se","text":""},{"location":"reference/se/#mongospecs.se","title":"se","text":""},{"location":"reference/se/#mongospecs.se.ATTRS_NOTHING_TYPE","title":"ATTRS_NOTHING_TYPE  <code>module-attribute</code>","text":"<pre><code>ATTRS_NOTHING_TYPE = NOTHING\n</code></pre>"},{"location":"reference/se/#mongospecs.se.MongoDecoder","title":"MongoDecoder  <code>module-attribute</code>","text":"<pre><code>MongoDecoder = Decoder(dec_hook=mongo_dec_hook)\n</code></pre>"},{"location":"reference/se/#mongospecs.se.MongoEncoder","title":"MongoEncoder  <code>module-attribute</code>","text":"<pre><code>MongoEncoder = Encoder(enc_hook=mongo_enc_hook)\n</code></pre>"},{"location":"reference/se/#mongospecs.se.mongo_dec_hook","title":"mongo_dec_hook","text":"<pre><code>mongo_dec_hook(typ: Any, obj: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/se.py</code> <pre><code>def mongo_dec_hook(typ: Any, obj: Any) -&gt; Any:\n    if typ is ObjectId:\n        return ObjectId(obj)\n    raise NotImplementedError(f\"Objects of type {type(obj)} are not supported\")\n</code></pre>"},{"location":"reference/se/#mongospecs.se.mongo_enc_hook","title":"mongo_enc_hook","text":"<pre><code>mongo_enc_hook(obj: Any) -&gt; Any\n</code></pre> Source code in <code>mongospecs/se.py</code> <pre><code>def mongo_enc_hook(obj: Any) -&gt; Any:\n    if obj is msgspec.UNSET or obj is ATTRS_NOTHING_TYPE:\n        return None\n    elif type(obj) == date:\n        return str(obj)\n    # Object Id\n    elif isinstance(obj, ObjectId):\n        return str(obj)\n\n    raise NotImplementedError(f\"Objects of type {type(obj)} are not supported\")\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":""},{"location":"reference/utils/#mongospecs.utils","title":"utils","text":""},{"location":"reference/utils/#mongospecs.utils.deep_merge","title":"deep_merge","text":"<pre><code>deep_merge(source: dict[str, Any], dest: dict[str, Any]) -&gt; None\n</code></pre> <p>Deep merges source dict into dest dict.</p> <p>This code was taken directly from the mongothon project: https://github.com/gamechanger/mongothon/tree/master/mongothon</p> Source code in <code>mongospecs/utils.py</code> <pre><code>def deep_merge(source: dict[str, Any], dest: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Deep merges source dict into dest dict.\n\n    This code was taken directly from the mongothon project:\n    https://github.com/gamechanger/mongothon/tree/master/mongothon\n    \"\"\"\n    for key, value in source.items():\n        if key in dest:\n            if isinstance(value, dict) and isinstance(dest[key], dict):\n                deep_merge(value, dest[key])\n                continue\n            elif isinstance(value, list) and isinstance(dest[key], list):\n                for item in value:\n                    if item not in dest[key]:\n                        dest[key].append(item)\n                continue\n        dest[key] = value\n</code></pre>"}]}